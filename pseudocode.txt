function tsp_backtracking(cities, times, weights, start_city, time_limit):
    # Initialize variables
    n = len(cities)
    visited = [False] * n
    visited[start_city] = True
    current_path = [start_city]
    current_time = times[start_city]
    current_cost = 0
    best_path = None
    best_cost = float('inf')

    # Define recursive function to search for solutions
    def backtrack(path, time, cost):
        nonlocal best_path, best_cost

        # If all cities have been visited, check if this is a new best solution
        if len(path) == n:
            cost += weights[path[-1]][start_city]
            if cost < best_cost:
                best_path = path + [start_city]
                best_cost = cost

        # If not all cities have been visited, continue search
        else:
            for i in range(n):
                if not visited[i]:
                    new_time = time + times[i] + weights[path[-1]][i]
                    if new_time <= time_limit:
                        visited[i] = True
                        path.append(i)
                        backtrack(path, new_time, cost + weights[path[-2]][i])
                        path.pop()
                        visited[i] = False

    # Start search with recursive function
    backtrack(current_path, current_time, current_cost)

    # Return best solution found
    return best_path, best_cost
